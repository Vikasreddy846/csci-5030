* **Class Discussion of “Real Software Engineering”**
    * Overall thoughts?
    * **Main idea 0**: Waterfall is linear.
        * Requirements -> analysis -> design -> coding -> testing -> operating.
        * Is software development linear? Why or why not?
    * **Main idea 1**: A majority of software development is responding to unknowns. Thus, we need a process for continued development in parallel to responding to unknowns effectively.
        * Has anyone ever coded something according to a design specification? Did the specification change before you were done writing the system?
        * Any experiences from students in the class that have been a part of defined process for software development?
        * How about from the other perspective– has anyone written software with no written specification? How often did the direction of that software change? How did the code respond?
    * **Main idea 2**: The shorter the feedback loop, the quicker we can respond to change.
        * Cost of errors curve in the original paper was really just measuring the _cost of errors_ in waterfall model. "Failure of waterfall incurs 100% cost overruns." What does that mean? You have to start over.
        * Cost of Errors v. Project Phase (time)
        * NUMBER of errors v project phase. Number of errors v lines of code. How does the _frequency_ of design and programming errors change through the project phase?
        * New graph: cost of errors v speed of feedback loop.
    * **Main idea 3**: Code should serve as executable model and documentation.
        * Has anyone written documentation for their code? Where did this documentation go? Did code and documentation ever get out of sync? How do you keep them in sync?
        * Should design software through documentation or design software through code? What are the tradeoffs? When do you think it’s appropriate to do one or the other?
        * Example of Add function. What’s a _useful_ comment for this function?
    * More Questions:
        * Is the waterfall model really just kept around by misguided academics? It's used still in plenty of industries– being seduced by it is not just an academic flaw... Why is it still pervasive today?
        * **Is the purpose of engineering really just to save cost?** "Do with one dollar what any fool could do with two." What about verification and accountability?
        * **Can engineering being an artistic pursuit?** What are the boundaries of the artistic value of software engineering?
        * What do we think about the author's following assumptions?
            * These assumptions are no longer true:
                * Code is hard to read
                * Code is hard to change
                * Testing is expensive
                * All engineering is like structural engineering
                * Programming is like building
                * Modeling and analysis are about correctness
* **Survey Results**
    * [Group assignments](https://docs.google.com/spreadsheets/d/1ntcrWhVZbbH5uEsr6RTBfuPLmUB4LYXrZX0iTEM6AlQ/edit?usp=sharing)
* **Semester Projects**
    * [Evernote 2.0](../briefs/evernote.md).
    * [Discord 2.0](../briefs/discord.md).
* **Group Breakout**
    * Meet.
    * Discuss which project you're most excited about.
    * Create a discord channel for your group to communicate through.
    * Coordinate to make sure you always bring at least 1 laptop to each class session.
    * Start thinking and communicating about which product you’d like to work on.    
* **Reading**
    * [The Agile Manifesto](https://agilemanifesto.org/) (1 minute)
    * [The Agile Principles](https://agilemanifesto.org/principles.html) (3 minutes)
        * Pick the top 3 principles that resonate with you. Be ready to talk about them.
    * [“It the Agile Manifesto Still a Thing?”](https://www.atlassian.com/agile/manifesto) (7 minutes)
    * [“What is Scrum?”](https://www.atlassian.com/agile/scrum) (Video, 4 minutes)
    * [“What are Sprints?”](https://www.atlassian.com/agile/scrum/sprints) (5 minutes)
